// Go :
// -компилируемый многопоточный яп
// -статически строго типизированный яп
// -Сборщик мусора в Go спроектирован с учётом приоритетности задержки и
//  избегания больших пауз, что особенно важно для серверов
// Go - регистрозависимый язык

/*
Комментарии создаются с помощью // или / *  * /

Глаголы форматирования

	%f Число с плавающей точкой
	%d Десятичное целое число
	%s Строка
	%t Логическое значение (true или false)
	%v Произвольное значение (подходящий формат выбирается на основании типа передаваемого значения)
	%#v Произвольное значение, отформатированное в том виде, в котором оно отображается в коде Go
	%T Тип переданного значения (int, string и т. п.)
	%% Знак процента (литерал)
	пример: fmt.Printf("num не изменился = %d \n", num)


Обьявдение и инициализация переменых:

	В go принят camelCase стиль
	Первая буква имени как переменной так и функции имеет верхний регистр только в том случае,
		если оно должно экспортироваться из пакета

	var имя_переменной тип_данных (определение переменной)
	var имя_переменной, имя_переменной, ... , ... тип_данных

	Если значение переменной присваивается одновременно с ее объявлением,
		тип переменной в объявлении обычно не указывают.
		Тип значения, присвоенного переменной, будет считаться типом этой переменной
		var numroom = 5 (тип переменной не указан, но определяеться как int)
		numroom := 5 // короткое обьявление переменной

(Если переменной не присвоено значение, то она имеет значение по умолчанию, которое определено для ее типа.
Для числовых типов это число 0, для логического типа - false, для строк - пустая строка("").
в массивах аналогично)


ТИПЫ ДАННЫХ :

Целочисленные типы данных
	int8   от -128 до 127 и занимает в памяти 1 байт (8 бит)
	int16: от -32768 до 32767 и занимает в памяти 2 байта (16 бит)
	int32: от -2147483648 до 2147483647 и занимает 4 байта (32 бита)
	int64: от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 и занимает 8 байт (64 бита)

	uint8:  от 0 до 255 и занимает 1 байт
	uint16: от 0 до 65535 и занимает 2 байта
	uint32: от 0 до 4294967295 и занимает 4 байта
	uint64: от 0 до 18 446 744 073 709 551 615 и занимает 8 байт

	int: представляет целое число со знаком, которое в зависимости о платформы
		может занимать либо 4 байта, либо 8 байт. То есть соответствовать либо int32, либо int64.

	uint: представляет целое беззнаковое число только без знака, которое, аналогично типу int,
		в зависимости о платформы может занимать либо 4 байта, либо 8 байт. То есть соответствовать либо uint32, либо uint64.

	byte: синоним типа uint8, представляет целое число от 0 до 255 и занимает 1 байт
	rune: синоним типа int32, представляет целое число от -2147483648 до 2147483647 и занимает 4 байта
		рунные литералы записываються в одинарные кавычки 'A' --> 65


Вещественные типы данных ( числа с плавающей точкой)
	float32: представляет число с плавающей точкой от 1.4*10-45 до 3.4*1038(для положительных). Занимает в памяти 4 байта (32 бита)
	float64: представляет число с плавающей точкой от 4.9*10-324 до 1.8*10308 (для положительных) и занимает 8 байт


Строковый тип данных
	Строка — это последовательность символов, заключенных в кавычки
		Cтроки являются неизменяемыми, то есть после создания нельзя изменять содержимое строки
		Cпециальные последовательности:
			\n — переход на новую строку,
			\t — табуляция,
			\`— одинарная кавычка,
			\« — двойная кавычка,
			\\ — обратный слеш.
		Также строка может содержать Unicode-символы. Для этого необходимо задать последовательность символов
		в формате \uXXXX, где XXXX — значение символа Unicode. Например, чтобы добавить знак ₽, нужно ввести \u20BD.


Логический тип данных
	Логический тип или тип bool может иметь одно из двух значений: true (истина) или false (ложь).


Константы
	Константа в go определяется при помощи ключевого слова const, после которой идет имя переменной,
	имя этой константы и опционально ее тип
	const pi = 3.141

В Go указатель — это отдельный тип данных


Составные типы данных

	Типы данных array и slice представляют упорядоченные коллекции элементов одного типа.
		Они отличаются в том, что массив имеет фиксированную длину, а срез (slice) - динамическую длину.

	Тип данных struct представляет составной тип, который позволяет объединять несколько значений разных типов в одну сущность

	Тип данных map представляет ассоциативный массив (отображение), который хранит пары ключ-значение.

	Тип данных interface определяет набор методов, которые должны быть реализованы другими типами. Он позволяет создавать полиморфные объекты.
*/

package main

import "fmt"

// создаем структуру car, в не main, чтобы функция exFuncS были в одной области видимости
type car struct {
	m string
	n int
}

func main() {

	num := 100

	fmt.Println("\nArray--------------------------------------------------------------")
	// 1 способ создания массива
	var myArray [3]int
	myArray[0] = 777
	myArray[1] = num
	myArray[2] = 200

	// 2 способ создание массива
	//var myArray [3]int = [3]int{777, 100, 200}

	// 3 способ создания массива
	//myArray := [3]int{777, 100, 200}

	// Если в квадратных скобках вместо длины указано троеточие,
	// то длина массива определяется, исходя из количества переданных ему элементов
	// var numbers = [...]int{1,2,3,4,5}   // длина массива 5

	fmt.Println(myArray)
	fmt.Printf("myArray[1] = %d, len(myArray) = %d \n", myArray[1], len(myArray))

	// функция которая принимает массив размером 3 типа int
	myFuncArray(myArray)

	// Оператор среза s[i:j] создает из последовательности s новый срез
	arrS := myArray[:1]
	fmt.Println(arrS)

	// Для добавления в срез применяется встроенная функция append(slice, value)
	arrS = append(arrS, 888, 999)
	fmt.Printf("arrS = %v \n", arrS)

	fmt.Println("\nMap----------------------------------------------------------------")
	// map - встроенный тип карты, реализующий неупорядочную хеш-таблицу
	//Карта m с ключами типа string и значениями типа int
	//Типы карт — это ссылочные типы, такие как указатели или фрагменты. и поэтому значение ma1 выше это nil;
	// он не указывает на инициализированную карту. Нулевая карта при чтении ведет себя как пустая карта,
	// но попытки записи в нулевую карту вызовут панику во время выполнения; не делай этого.
	//Для инициализации карты используйте встроенный make функция:
	//ma1 := make(map[string]int) // короткое обьявление
	var ma1 map[string]int // обьявление переменной карты
	ma1 = make(map[string]int)
	fmt.Println(ma1["a"]) // 0
	ma1["a"] = 1
	ma1["a"]++
	ma1["b"] = 3
	fmt.Println(ma1) // map[a:2 b:3]
	// delete функция ничего не возвращает и ничего не сделает, если указанный ключ не существует
	delete(ma1, "a")
	// обращение к ключу карты может возвращать и второе (логическое)значение
	// true, если возвращаемое значение было реально присвоенов карте
	//  или false, если возвращаемое значение просто представляет нулевое значение поумолчанию
	param1, ok := ma1["a"]
	// _, ok := ma1["a"] // чтобы проверить только ключь без получения значения
	fmt.Printf("param1 = %d, ok = %t \n", param1, ok) // param1 = 0, ok = false

	//Если набор ключей и значений, которыми должна инициализироваться карта, известен заранее, то
	ma2 := map[string]int{"iv": 57, "se": 92}
	fmt.Println(ma2) // map[iv:57 se:92]

	fmt.Println("\nPointers-----------------------------------------------------------")
	//Функция может изменить только копию значения параметра, но не оригинал.
	// Таким образом, любые изменения,внесенные внутри функции, не будут видны за ее пределами!
	eF := exFor(1, num)
	fmt.Printf("res for eF = %d \n", eF)
	fmt.Printf("num не изменился = %d \n", num) //т.к. в функцию передаеться копия переменной

	//Оператор & (амперсанд) используется в Go для получения адреса переменной
	fmt.Printf("адрес хранения num = %v \n", &num)

	//Значения, представляющие адреса переменных, называются указателями,
	// потому что они указывают на область памяти, в которой хранится переменная
	//var numL *int //создаем переменную с указателем типа int
	//numL = &num  // указатель присваиваеться переменной
	numLink := &num // короткое обьявление переменной-указателя. теперь numLink это указатель
	fmt.Printf("(значение по указателю) *numLink = %d \n", *numLink)
	*numLink = 2
	fmt.Printf("теперь num изменилась через переменную *numLink и num равно = %d \n", num)

	// пример фунции которая изменяет переменную
	mlink(&num)
	fmt.Printf("теперь num изменилась через функцию mlink() и num равно = %d \n", num)

	fmt.Println("\nFunc---------------------------------------------------------------")
	// пример - функция принимает и возвращает два параметра сразу
	resPaint, err := exFuncEnterExit(2.0, 1.5)
	fmt.Printf("Amount of paint - %0.2f, error - %v \n", resPaint, err)

	//Функции с переменным количеством аргументов
	resf1 := exFuncArg(7, 6, 5, 4, 3, 2, 1)
	fmt.Printf("res1 = %d \n", resf1)
	resf2 := exFuncArg(7, 6)
	fmt.Printf("res2 = %d \n", resf2)
	//передаем массив в функцию в качестве параметра
	resf3 := exFuncArg(resf1...)
	fmt.Printf("res3 = %d \n", resf3)

	fmt.Println("\nstruct-------------------------------------------------------------")
	// если создаем структуру через var, значит на основе ее нельзя создать другие переменные
	// придеться каждый раз заново создовать для новой переменной
	var myStruct struct {
		name string
		age  int
	}
	fmt.Println(myStruct)
	myStruct.name = "nik"
	myStruct.age = 33
	fmt.Println(myStruct.name, myStruct.age)

	// если создаем струкуру через type, значит на ее основе можем создовать другие переменные
	// Тип структуры записывается только один раз, как базовый тип для определяемого типа
	// определяем тип person
	type person struct {
		name string
		age  int
		ok   bool
	}
	var dev person
	dev.name = "sergey"
	dev.age = 33
	fmt.Println(dev.name, dev.age)
	var ani person
	ani.name = "may"
	ani.age = 27
	fmt.Println(ani.name, ani.age)
	// второй способ обьявления
	mi := person{"mi", 18, true}
	mi.name = "miiilka"
	fmt.Println(mi.name)
	// третий способ обьявления и здесь все заплнено нулевым значение
	ol := person{}
	fmt.Println(ol)

	// создаем переменную типа car, которую создали в начале файла
	ji := car{"jip", 4356}
	fmt.Println(ji)
	//exFuncS(ol) - будет ошибка, не тот тип // функция принимает только тип car
	// значения в функцию передаються копией переменных и вне функции не изменяються
	//exFuncS(ji) // undefined 0
	fmt.Println(ji) // {jip 4356}
	// теперь значения изменяться
	exFuncS(&ji)
	fmt.Println("----", ji)

	fmt.Println("\nmethod-------------------------------------------------------------")
	ji.myMethodCar()
	fmt.Println("ji.myMethodCar() --> ", ji)

	fmt.Println("\n")
}

func exFor(e int, numm int) int {
	for i := e; i < 3; i++ {
		numm += i
	}
	return numm + 100
}

func exFuncEnterExit(width float64, height float64) (float64, error) {
	if width < 0 {
		return 0, fmt.Errorf("a width of %0.2f is invalid", width)
	}
	if height < 0 {
		return 0, fmt.Errorf("a height of %0.2f is invalid", height)
	}
	area := width * height
	return area / 10.0, nil
}

func myFuncArray(arr [3]int) {
	//for index, _ := range arr {
	for index, value := range arr {
		fmt.Printf("index = %d, value = %d \n", index, value)
	}
}

// Функции с переменным количеством аргументов
func exFuncArg(params ...int) []int {
	var res []int
	for _, value := range params {
		value += 2
		res = append(res, value)
	}
	return res
}

func mlink(i *int) {
	*i = 100200
}

// здесь функция принимате переменную с типом car
func exFuncS(p *car) {
	p.m = "undefined"
	p.n = 0000
	fmt.Println(p.m, p.n)
}

// если внутри метода не ставим * то значение будут изменены только внутри метода
func (c *car) myMethodCar() {
	c.m = "jjj"
	c.n = 333
}
